---
title: 图像处理岗位面试题搜罗汇总
date: 2017-09-14 15:59:00
tags: 
- 面试
- 机器视觉
categories: 机器学习
---

图像处理岗位面试题搜罗汇总
<!-- more -->

## 图像处理部分

### 低层优化相关

#### Intel指令集中MMX,SSE,SSE2,SSE3和SSE4指的是什么？

MMX（Multi Media eXtension，多媒体扩展指令集）是一些整数并行运算指令。

SSE（Streaming SIMD Extensions，单指令多数据流扩展）是一系列浮点并行运算指令。

#### 并行计算有哪些实现方式？

单指令多数据流SIMD、对称多处理机SMP、大规模并行处理机MPP、工作站机群COW、分布共享存储DSM多处理机。

#### 卷积和相关

相关是滤波器模板移过图像并计算计算每个位置乘积之和的处理；卷积的机理相似，但滤波器首先要旋转180度

相关的计算步骤：

1. 移动相关核的中心元素，使它位于输入图像待处理像素的正上方
1. 将输入图像的像素值作为权重，乘以相关核
1. 将上面各步得到的结果相加做为输出

卷积的计算步骤：

1. 卷积核绕自己的核心元素顺时针旋转180度
1. 移动卷积核的中心元素，使它位于输入图像待处理像素的正上方
1. 在旋转后的卷积核中，将输入图像的像素值作为权重相乘
1. 第三步各结果的和做为该输入像素对应的输出像素

超出边界时要补充像素，一般是添加0或者添加原始边界像素的值，可以看出他们的主要区别在于计算卷积的时候，卷积核要先做旋转。

而计算相关过程中不需要旋转相关核。

离散单位冲击：我们将包含单个1而其余全是0的函数成为离散单位冲击。
重要性质：一个函数与离散单位冲击相关，在冲击位置产生这个函数的一
个翻转版本。

```
f 函数
w 滤波器模板
eg：
f（x，y）
  0 0 0 0 0
  0 0 0 0 0 
  0 0 1 0 0
  0 0 0 0 0
  0 0 0 0 0
w（x，y）
  1 2 3 
  4 5 6 
  7 8 9
相关 f*w = 
     0     0     0     0     0
     0     9     8     7     0
     0     6     5     4     0
     0     3     2     1     0
     0     0     0     0     0
卷积f*w=
     0     0     0     0     0
     0     1     2     3     0
     0     4     5     6     0
     0     7     8     9     0
     0     0     0     0     0
相关的用途：图象的匹配
```

### 图像基础知识

#### 彩色图像、灰度图像、二值图像和索引图像区别？

彩色图像：RGB图像。灰度图像：0-255像素值。二值图像：0和1，用于掩膜图像。

索引图像：在灰度图像中，自定义调色板，自定义输出256种颜色值。

#### 常用的图像空间

HSI、HSV、RGB、CMY、CMYK、HSL、HSB、Ycc、XYZ、Lab、YUV色彩空间（颜色模型）

RGB颜色空间

RGB(red,green,blue)颜色空间是算法处理中应用最多的颜色空间。

HSI颜色空间，色调（Hue）、色饱和度（Saturation或Chroma）和亮度（Intensity或Brightness）

YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。YUV 4:4:4采样，每一个Y对应一组UV分量。YUV 4:2:2采样，每两个Y共用一组UV分量。 YUV 4:2:0采样，每四个Y共用一组UV分量。 紧缩格式（packed formats）平面格式（planar formats）。YYYYYYYYUVUV YYYYYYYYUUVV

#### 图像的像素数与分辨率有什么区别？

像素数为图像实际组成的像素的个数，像素是没有固定宽度和高度的，是一个感光单元。

分辨率的单位为 像素/英寸（1英寸（inch）=2.54厘米（cm）），这里指的不是面积，而是对角线的长度，即dpi、ppi。分辨率也称之为点密度，分辨率越高，看的越细腻。

#### 视频帧播放速度的单位

PAL制式是——25fps，NTSC是——30fps。

### 图像预处理

#### 叙述GABOR滤波器原理？

使用一个三角函数(如正弦函数)与一个高斯函数叠加我们就得到了一个Gabor滤波器。Gabor滤波器却可以抽取空间局部频度特征，是一种有效的纹理检测工具。

附：图像的空域是指二维坐标系上的操作，频域指的是图像经过傅里叶变换后的频谱。在频率域中，高频分量表示图像中灰度变换比较快的那些地方，比如物体的边缘就是灰度的突然变化，所以物体边缘就是高频分量。而物体内部比较平坦的区域，灰度基本没有变化，对应的就是低频分量。比如低通滤波只让低频分量通过，往往就是使图像模糊，因为边缘信息被去除了。高频对应图像细节，低频对应图像大致轮廓。

#### 椒盐噪声用什么滤波处理比较有效？

[参考：中值滤波与椒盐噪声](http://blog.csdn.net/zbc1090549839/article/details/38404995)

椒盐噪声：也称为脉冲噪声：

在图像中，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。

滤除椒盐噪声比较有效的方法是对信号进行中值滤波处理。

### 插值

#### 最近邻插值

#### 双线性插值

#### 立方卷积插值

### 特征算子

#### 常用边缘检测有哪些算子，各有什么特性？

1. **Sobel算子**：典型的基于一阶导数的边缘检测算子，对于像素的位置的影响做了加权，可以降低边缘模糊程度。
    
    不足：没有将图像的主体与背景严格地区分开来, 没有基于图像灰度进行处理.

    卷积核和像素更新公式如下：

    $$
    G_x=\left[ \begin{matrix} -1 & 0 & +1 \\ -2 & 0 & +2 \\ -1 & 0 & +1 \end{matrix} \right]
    G_y=\left[ \begin{matrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ +1 & +2 & +1 \end{matrix} \right]
    G = \sqrt{ {G_x}^2 + {G_y}^2 }
    $$
1. **Isotropic Sobel**：各向同性Sobel(Isotropic Sobel)算子。各向同性Sobel算子和普通Sobel算子相比，它的位置加权系数更为准确，在检测不同方向的边沿时梯度的幅度一致。

    卷积核和像素更新公式如下：

    $$
    G_x=\left[ \begin{matrix} -1 & 0 & +1 \\ -\sqrt2 & 0 & +\sqrt2 \\ -1 & 0 & +1 \end{matrix} \right]
    G_y=\left[ \begin{matrix} -1 & -\sqrt2 & -1 \\ 0 & 0 & 0 \\ +1 & +\sqrt2 & +1 \end{matrix} \right]
    G = \sqrt{ {G_x}^2 + {G_y}^2 }
    $$
1. **Roberts算子**：一种利用局部差分算子寻找边缘的算子。

    不足：对噪声敏感,无法抑制噪声的影响。

    卷积核和像素更新公式如下：

    $$
    G_x=\left[ \begin{matrix} -1 \\ +1 \end{matrix} \right]
    G_y=\left[ \begin{matrix} -1 & +1 \end{matrix} \right]
    G = \sqrt{ {G_x}^2 + {G_y}^2 }
    $$

    检测对角线方向梯度时：

    $$
    G_x=\left[ \begin{matrix} -1 & 0 \\ 0 & +1 \end{matrix} \right]
    G_y=\left[ \begin{matrix} 0 & -1 \\ +1 & 0 \end{matrix} \right]
    G = \sqrt{ {G_x}^2 + {G_y}^2 }
    $$
1. **Prewitt算子**：Sobel是该算子的改进版。

    卷积核和像素更新公式如下：

    $$
    G_x=\left[ \begin{matrix} -1 & 0 & +1 \\ -1 & 0 & +1 \\ -1 & 0 & +1 \end{matrix} \right]
    G_y=\left[ \begin{matrix} -1 & -1 & -1 \\ 0 & 0 & 0 \\ +1 & +1 & +1 \end{matrix} \right]
    G_x'=\left[ \begin{matrix} -1 & -1 & 0 \\ -1 & 0 & +1 \\ 0 & +1 & +1 \end{matrix} \right]
    G_y'=\left[ \begin{matrix} 0 & 1 & 1 \\ -1 & 0 & 1 \\ -1 & -1 & 0 \end{matrix} \right]
    $$
1. **Laplacian算子**：拉普拉斯算子,各向同性算子，二阶微分算子,只适用于无噪声图象,存在噪声情况下，使用Laplacian算子检测边缘之前需要先进行低通滤波。

    卷积核和像素更新公式如下：
    
    $$
    R=\left[ \begin{matrix} -1 & -1 & -1 \\ -1 & 8 & -1 \\ -1 & -1 & -1 \end{matrix} \right]
    G=\left\{ \begin{matrix} 1 & |R(x,y)| \ge T \\ 0 & others \end{matrix} \right.
    $$
1. **Canny算子**：一个具有滤波，增强，检测的多阶段的优化算子。先利用高斯平滑滤波器来平滑图像以除去噪声，采用一阶偏导的有限差分来计算梯度幅值和方向，然后再进行非极大值抑制。
1. **Laplacian of Gaussian(LoG)算子**：先对图像做高斯滤波，再做Laplacian算子检测。

#### 请描述以下任一概念：SIFT/SURF  LDA/PCA

SIFT/SURF为了实现不同图像中相同场景的匹配，主要包括三个步骤：
1. 尺度空间的建立；
2. 特征点的提取；
3. 利用特征点周围邻域的信息生成特征描述子
4. 特征点匹配。

之所以采用尺度空间，是为了应对尺度不变性。

**SIFT**

1. 生成高斯差分金字塔（DOG金字塔），尺度空间构建
    - 通过对原始图像进行尺度变换，获得图像多尺度下的尺度空间表示序列
    - 对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为一种特征向量，实现边缘、角点检测不同分辨率上的关键点提取等
    - 尺度空间构建的基础是DOG金字塔，DOG金字塔构建的基础是高斯金字塔
2. 空间极值点检测（关键点的初步查探）
    - 为了寻找DOG函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度空间域的相邻点大或者小
    - 在二维图像空间，中心点与它`3*3`邻域内的8个点做比较，在同一组内的尺度空间上，中心点和上下相邻的两层图像的`2*9`个点作比较，如此可以保证检测到的关键点在尺度空间和二维图像空间上都是局部极值点
    - ![](http://img.blog.csdn.net/20160918211309513)
3. 稳定关键点的精确定位
    - DOG值对噪声和边缘比较敏感，所以在第2步的尺度空间中检测到的局部极值点还要经过进一步的筛选，去除不稳定和错误检测出的极值点，另一点就是在构建高斯金字塔过程中采用了下采样的图像，在下采样图像中提取的极值点对应在原始图像中的确切位置，也是要在本步骤中解决的问题。
4. 稳定关键点方向信息分配
    - 稳定的极值点是在不同尺度空间下提取的，这保证了关键点的尺度不变性。为关键点分配方向信息所要解决的问题是使得关键点对图像角度和旋转具有不变性。方向的分配是通过求每个极值点的梯度来实现的。
    - 分配给关键点的方向并不直接是关键点的梯度方向，而是按照一种梯度方向直方图的方式给出的。
    - 具体的方法是：计算以关键点为中心的邻域内所有点的梯度方向，当然梯度方向一定是在0~360°范围内，对这些梯度方向归一化到36个方向内，每个方向代表了10°的范围。然后累计落到每个方向内的关键点个数，以此生成梯度方向直方图。
    - ![](http://img.blog.csdn.net/20160918212038619)
    - ![](http://img.blog.csdn.net/20160918212042391)
    - ![](http://img.blog.csdn.net/20160918212445002)
5. 关键点描述
    - 对关键点的描述是后续实现匹配的关键步骤，描述其实就是一种以数学方式定义关键的过程。描述子不但包含关键点，也包括关键点周围对其有贡献的邻域点。
    - 描述的思路是：对关键点周围像素区域分块，计算快内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象表述。
    - 如下图，对于`2*2`块，每块的所有像素点的荼毒做高斯加权，每块最终取8个方向，即可以生成`2*2*8`维度的向量，以这`2*2*8`维向量作为中心关键点的数学描述。
    - David G.Lowed的实验结果表明：对每个关键点，采用4*4*8共128维向量的描述子进项关键点表征，综合效果最佳：
    - ![](http://img.blog.csdn.net/20160918213353043)
    - ![](http://img.blog.csdn.net/20160918213601343)
6. 特征点匹配
    - 特征点的匹配是通过计算两组特征点的128维的关键点的欧式距离实现的。欧式距离越小，则相似度越高，当欧式距离小于设定的阈值时，可以判定为匹配成功。

**线性判别分析（LDA）, 主成分分析(PCA)**

[参考](http://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html)、 [参考](http://dataunion.org/13451.html)

LDA和PCA最终的表现都是解一个矩阵特征值的问题,分类的目标是，使得类别内的点距离越近越好（集中），类别间的点越远越好。

LDA的全称是Linear Discriminant Analysis（线性判别分析），是一种supervised learning。

LDA的原理是，将带上标签的数据（点），通过投影的方法，投影到维度更低的空间中，使得投影后的点，会形成按类别区分，一簇一簇的情况，相同类别的点，将会在投影后的空间中更接近。要说明白LDA，首先得弄明白线性分类器(Linear Classifier)：因为LDA是一种线性分类器。对于K-分类的一个分类问题，会有K个线性函数 y = wx+b.

当满足条件：对于所有的j，都有Yk > Yj,的时候，我们就说x属于类别k。对于每一个分类，都有一个公式去算一个分值，在所有的公式得到的分值中，找一个最大的，就是所属的分类了。

y = wx+b实际上就是一种投影，是将一个高维的点投影到一条高维的直线上，LDA最求的目标是，给出一个标注了类别的数据集，投影到了一条直线之后，能够使得点尽量的按类别区分开

主成分分析（PCA）与LDA有着非常近似的意思，LDA的输入数据是带标签的，而PCA的输入数据是不带标签的，所以PCA是一种unsupervised learning。

PCA更像是一个预处理的方法，它可以将原本的数据降低维度，而使得降低了维度的数据之间的方差最大

它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。

通俗的理解，如果把所有的点都映射到一起，那么几乎所有的信息（如点和点之间的距离关系）都丢失了，而如果映射后方差尽可能的大，那么数据点则会分散开来，以此来保留更多的信息。可以证明，PCA是丢失原始数据信息最少的一种线性降维方式。（实际上就是最接近原始数据，但是PCA并不试图去探索数据内在结构）

Linear Discriminant Analysis (也有叫做Fisher Linear Discriminant)是一种有监督的（supervised）线性降维算法。与PCA保持数据信息不同，LDA是为了使得降维后的数据点尽可能地容易被区分！

#### 特征点匹配

如下图所示，请以准确快速实现配准为目标，设计算法，让两图中对应的特征点（至少一部分特征点）配准（即精准地地找出对应点之间对应的坐标关系值）。

![](http://img.blog.csdn.net/20131102205402359)

[参考](http://blog.csdn.net/dcrmg/article/details/52577555)

之前是用角点检测，后来采用SIFT算子，Sift算法的实质是在不同的尺度空间上查找关键点（特征点），计算关键点的大小、方向、尺度信息，利用这些信息组成关键点对特征点进行描述的问题。

1. 生成高斯差分金字塔（DOG金字塔），尺度空间构建
2. 空间极值点检测（关键点的初步查探）
3. 稳定关键点的精确定位
4. 稳定关键点方向信息分配
5. 关键点描述（128维向量算子）
6. 特征点匹配（欧氏距离）

#### 极值点邻域筛选

对于一般应用图像中，景物可能存在任意特征（如折线，弧形、亮度极值、色调等），请设计合适的算法，找到图像中可以作为明显特征点的灰度的极值点所在的邻域。以准确快速实现极值点邻域筛选为目标，设计算法。用流程图表达）。

也使用SIFT特征

### 分类算法

#### 常用的分类器有哪些，并简述其原理？

线性分类器：Logistic回归 y=sigmoid(wx+b)

传统方式：特征描述和检测

KNN，K最近邻，判断图像与各个类别的距离

SVM，选定特征， SVM算法输出一个最优化的分隔超平面（分类面）。本科课题：SIFT、k-means、Bag of Words、SVM。映射函数可能为多项式。

BPNN，全连接网络，计算量巨大

CNN，卷积神经网络

迁移学习，利用别人训练好的参数，自定义网络

#### KNN的计算步骤

#### 简述BP神经网络

BP(back propagation)神经网络，输入X，通过隐藏节点的非线性变换后，输出信号Y，通过误差分析，来调整隐藏节点的W和b。

#### AdBoost的基本原理？

AdBoost是一个广泛使用的BOOSTING算法，其中训练集上依次训练弱分类器，每次下一个弱分类器是在训练样本的不同权重集合上训练。权重是由每个样本分类的难度确定的。分类的难度是通过分类器的输出估计的。

[参考资料](http://blog.csdn.net/whiteinblue/article/details/14518773)

//TODO 详细学习

### 聚类算法

#### 简述你熟悉的聚类算法并说明其优缺点

**K均值聚类（K-meansClustering）**

将输入数据分到K个类中。K均值是通过循环更新类中心的初始估计值来实现的。优势是实现起来很简单，是并行化的。主要缺陷是，类的数目需要提前确定。

主要分三步：
1. 随机选取k个聚类质心点（cluster centroids）
2. 对于每一个样例i，计算其应该属于的类
3. 对于每一个类j，重新计算该类的质心
1. 重复下面过程直到收敛 

**层次聚类**

层次聚类（或者叫做凝聚聚类）是另一个简单但是强大的聚类算法。其思想是基于成对距离建立一棵相似度树。该算法首先分组成为两个最近的对象（基于特征向量之间的距离），并且在一棵有着两个对象作为孩子的树中创建一个平均结点。然后在余下的结点中找到一个最近的pair，并且也包含任何平均节点，等等。在每一个结点，两个孩子之间的距离也会被存储。簇然后可以通过遍历这棵树并在距离比某个阈值小以至于决定聚类的大小的结点处停止来被提取出来。

层次聚类有几个优势。比如，树结构可以被用来可视化关系，并且显示簇是如何关联起来的。一个好的特征向量将得到树中好的分离。另一个优势是树可以在不同的簇阈值中被重用，而不需要重新计算树。**缺点是需要选择一个阈值如果实际的簇需要的话**。

**谱聚类**

对于n个元素的相似度矩阵（或者叫affinity matrix， 有时也叫距离矩阵）是一个有着成对相似度分数的n*n矩阵。谱聚类的这个名称是从相似度矩阵构造的矩阵的谱的使用得来。这个矩阵的特征向量被用来降维，然后再聚类。

谱聚类方法的其中一个优势是唯一的输入就是这个矩阵，并且可以被你可以想到的任何相似度度量构造出来。像K均值和层次聚类这样的方法计算特征向量的平均值，这个限制了特征（或者是描述符）对向量（为了能够计算平均值）。有了谱方法，不再需要任何类型的特征向量，只有“距离”或者“相似度”。

**Mean Shift 聚类算法**

1. 在未被标记的数据点中随机选择一个点作为中心center；
1. 找出离center距离在bandwidth之内的所有点，记做集合M，认为这些点属于簇c。同时，把这些求内点属于这个类的概率加1，这个参数将用于最后步骤的分类
1. 以center为中心点，计算从center开始到集合M中每个元素的向量，将这些向量相加，得到向量shift。
1. center = center+shift。即center沿着shift的方向移动，移动距离是||shift||。
1. 重复步骤2、3、4，直到shift的大小很小（就是迭代到收敛），记住此时的center。注意，这个迭代过程中遇到的点都应该归类到簇c。
1. 如果收敛时当前簇c的center与其它已经存在的簇c2中心的距离小于阈值，那么把c2和c合并。否则，把c作为新的聚类，增加1类。
1. 重复1、2、3、4、5直到所有的点都被标记访问。
1. 分类：根据每个类，对每个点的访问频率，取访问频率最大的那个类，作为当前点集的所属类。

简单的说，mean shift就是沿着密度上升的方向寻找同属一个簇的数据点。

### 图像分割

#### Graph-cut的基本原理和应用？

Graph cuts是一种十分有用和流行的能量优化算法，在计算机视觉领域普遍应用于前背景分割（Image segmentation）、立体视觉（stereo vision）、抠图（Image matting）等。

利用图，将目标和背景进行分割。

### 图像融合，镶嵌

已知两幅拼接好的图像，两幅图像在几何关系配准之后，但两图之间存在明显灰度差别跳变，请设计一个算法对图像进行处理，让两幅图之间的灰度看不出跳变，形成自然过渡。（可以不考虑两图之间的黑图部分）。

![](http://img.blog.csdn.net/20131102205608671)

影像融合是指高分辨率灰度图像和低分辨率彩色图像融合得到具有高分辨率的彩色图像。该算法称之为图像镶嵌。简单的做法可以是寻找两幅影像的镶嵌线，镶嵌线是指两幅影像公共区域区别最小的一条线，可以利用相关系数法判断得到，然后根据镶嵌线上两幅影像的灰度差异对右影像进行反差调整，最后拼接。

### 其他模型

#### Random Forest的随机性表现在哪里。

**Bagging方法**是ensemble methods中获得用于训练base estimator的数据的重要一环。 正如其名，Bagging方法就是将所有training data放进一个黑色的bag中，黑色意味着我们看不到里面的数据的详细情况，只知道里面有我们的数据集。然后从这个bag中随机抽一部分数据出来用于训练一个base estimator。抽到的数据用完之后我们有两种选择，放回或不放回。

我们可以看到从根节点开始往下会有分支，最终会走向叶子节点，得到分类结果。每一个非叶子节点都是一个特征，上图中共有三维特征。但是决策树的一个劣势就是容易过拟合，下面我们要结合上文提到的bagging技术来中和一下。

![](http://keepcodingblog.qiniudn.com/DT-1.jpg)

**bagging + decision trees**，我们得到了随机森林。将决策树作为base estimator，然后采用bagging技术训练一大堆小决策树，最后将这些小决策树组合起来，这样就得到了一片森林(随机森林)。

(X[1],Y[1])....(X[n],Y[n])是数据集，我们要训练T棵决策树g[1]....g[t]...g[T]。 每次从数据中有放回地随机抽取size-N'的子数据集D[t]用于训练第t棵决策树g[t]。

随机森林的随机性体现在每颗树的训练样本是随机的，树中每个节点的分裂属性集合也是随机选择确定的。有了这2个随机的保证，随机森林就不会产生过拟合的现象了。

#### GMM的基本原理和应用

高斯混合模型（Gaussian Mixture Model, GMM）将一个事物分解为若干的基于高斯概率密度函数（正态分布曲线）形成的模型。

高斯混合模型(GMM，Gaussian mixture model)是建模最为成功的方法之一，同时GMM可以用在监控视频索引与检索。

用于动目标检测中的背景建模。

- 混合高斯模型使用K（++基本为3到5个++） 个高斯模型来表征图像中各个像素点的特征。 
- 在新一帧图像获得后更新混合高斯模型,用当前图像中的每个像素点与混合高斯模型匹配,如果成功则判定该点为背景点, 否则为前景点。 
- 通观整个高斯模型，他主要是有++方差++和++均值++两个参数决定，,对均值和方差的学习,采取不同的学习机制,将直接影响到模型的稳定性、精确性和收敛性。 
- 由于我们是对运动目标的背景提取建模，因此需要对高斯模型中方差和均值两个参数实时更新。 
- 为提高模型的学习能力,改进方法对均值和方差的更新采用不同的学习率 
- 为提高在繁忙的场景下,大而慢的运动目标的检测效果,引入权值均值的概念,建立背景图像并实时更新,然后结合权值、权值均值和背景图像对像素点进行前景和背景的分类。

### 监督学习和非监督学习。

- 监督学习：通过已有的一部分输入数据与输出数据之间的对应关系，生成一个函数，将输入映射到合适的输出，例如分类。
- 非监督学习：直接对输入数据集进行建模，例如聚类。
- 半监督学习：综合利用有类标的数据和没有类标的数据，来生成合适的分类函数。

目前最广泛被使用的分类器有人工神经网络、支持向量机、最近邻居法、高斯混合模型、朴素贝叶斯方法、决策树和径向基函数分类。

无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，而我们并不关心这一类是什么。因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。

### 图像算法

#### 二值图像连通域搜索

matlab中连通区域标记函数bwlabel中的算法，一次遍历图像，并记下每一行（或列）中连续的团（run）和标记的等价对，然后通过等价对对原来的图像进行重新标记。

1. 创建RUN（团）结构体，包含（纵坐标、横坐标开始、横坐标结束、标记号）
1. 开始逐行扫描图像，寻找所有的团，将他们放到一个二维数组`vector< vector<Stuct> >`中，以下为每一行的操作。
	1. 当遇到一个255时，创建一个团的对象，标记纵坐标和横坐标的开始。
	1. 从开始点向右寻找，直到遇到0或者这行结束，则标记为这个团的横坐标结束。
	1. 将该行的RUN push到对应的位置。回到步骤2.1.
1. 对众多的团进行分析，对团进行标记且得到等价对，创建一个`vector< pair<int, int> >`用于存放所有的等价对。
	1. 遍历所有相邻行。
	1. 若该行为第一行，则直接进行标记。
	1. 对于相邻行，遍历该行的所有RUN，对于每一个RUN，遍历上一行的所有RUN（超出范围即停止循环）。
		1. 若上一行中没有与该行RUN邻接，则创建新的标记。
		1. 若上一行只有一个与该RUN邻接，则沿用相邻RUN的标记。
		1. 若上一行有多个与该RUN邻接，则使用这多个RUN中最小的标记，并创建多个等价对。
1. 消除等价对，可使用并查集，使得所有的团都拥有自己的祖先。
	1. 假设标记从0开始，到1000结束。标记对为类似的(0,10).(10,39)。
	1. 创建一个prev[1000]数组，初始化值为-1，记录该标记的上一级领导。初始prev[10]=0,prev[39]=10。初始化所有的等价对。
	1. 遍历所有的等价对，修改每一级的上一级领导为最上层领导。
1. 修改每个团中的标记为最上层领导的标记。

代码见[github](https://github.com/liqiang311/snippets/blob/master/%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E8%BF%9E%E9%80%9A%E5%9F%9F%E9%97%AE%E9%A2%98.cpp)

开源库cvBlob中使用的标记算法，它通过定位连通区域的内外轮廓来标记整个图像，这个算法的核心是轮廓的搜索算法

TODO:轮廓跟踪算法

## 图像相关开放性知识

### 怎样在一张街拍图像中识别明星的衣着服饰信息？

我们需要把服装与背景、人物、建筑等等元素区别开来,确定是否有衣服以及衣服在什么位置。接下来需要对衣服进行分析,提取出服装的属性、特征等等。最后再根据这些特征,在庞大的数据库里搜索同款或者类似的服装图片。

### 上衣纯色，裙子花色，怎样做区分？

方差判断，梯度变化。

### 怎样判断一张广告图片中是否有文字信息？是否用到OCR技术？怎样应用？

场景文字检测与识别，先用CNN等对文字进行定位，然后再使用LSTM、OCR进行文字识别。

### 给一张二值化图片(包含一个正方形)，怎样识别图片中的正方形？如果图片污损严重，怎样识别并恢复？

首先检测轮廓，然后对轮廓进行分析（角点）。

如果图像污损严重，如何识别？

### 简述图像识别在移动互联网中的应用

人脸识别、识别各类东西、检索各类图像。

### 图像处理领域相关顶级论文

- Image and Vision Computing   (IVC)
- Pattern Recognition          (PR)
- ICCV: IEEE International Conference on Computer Vision
- CVPR: IEEE Conf on Comp Vision and Pattern Recognition
- NIPS: Neural Information Processing Systems

## 数学知识

### 公式

#### 贝叶斯全概率公式题

**全概率公式**

对任一事件A,若有互不相容的事件$B_i(i=1,2,...,n)$,满足$P(B_i)>0,\sum_{i=1}^n{P(B_i)}=1(i=1,2,...,n)$且$\sum_{i=1}^n{B_i} \supset A$，则事件A的概率可用下式计算：

$$
P(A)=\sum_{i=1}^n {P(B_i)P(A|B_i)}
$$

![](http://netclass.csu.edu.cn/NCourse/hep013/gltj/1/gltj1711.files/image005.gif)

此概率称之为全概率公式。

**Bayes公式**

利用乘法公式与全概率公式可导出Bayes公式

对任一事件A，若有互不相容的事件$B_i(i=1,2,…,n)$,满足$P(B_i)>0,\sum_{i=1}^n{P(B_i)}=1(i=1,2,...,n)$且$\sum_{i=1}^n{B_i} \supset A$，（跟上个公式条件相同）则

$$
P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum_{i=1}^n {P(B_i)P(A|B_i)}}(i=1,2,…,n)
$$

#### 最小二乘拟合的公式推导和代码实现。

最小二乘法通常用于 曲线拟合 (least squares fitting) 。

[推导过程](http://www.cnblogs.com/dotLive/archive/2007/04/06/524633.html)

核心思想是最小化损失函数：距离差值的平方（$(di-R)^2$），若想公式可导，则可以计算平方差的平方$(di^2-R^2)^2$

## C/C++部分

### 基本概念

#### 关键字static的作用是什么？

1. 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
1. 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数，它是一个本地的全局变量。
1. 在模块内，一个被声明为静态的函数只可被这一模块的它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

#### 简述C，C++程序编译的内存分配情况？

C，C++中内存分配方式可以分为三种：  

1. 从静态存储区域分配：内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快，不容易出错，因有系统自行管理。它主要存放静态数据、全局数据和常量。会默认初始化，其他两个不会自动初始化。
1. 在栈上分配：在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
1. 从堆上分配：即运态内存分配。程序在运行时候用malloc或new申请任意大小的内存，程序员自己负责在何进用free 和delete释放内存。

一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区和程序代码区。

### 图的遍历

#### 深度搜索DFS

递归写法

1. 定义一个visited数组。
1. 访问当前节点，输出该节点。
1. 循环遍历该节点的相邻的，未被访问过的节点。
	1. 递归第二步。

非递归写法

1. 定义一个栈和一个visited数组。
1. 将初始节点入栈。开始循环，直道栈空。循环如下：

#### 广度搜搜BFS

设置队列

1. 定义一个队列Queue和visited数组。
1. 将开头节点入队。
1. 开始循环
	1. 出队，访问该节点
	1. 遍历该节点的相邻的未被访问过的节点，入队

### 其他编程

#### 嵌入式系统总是用户对变量或寄存器进行位操作。给定一个整型变量a,写两段代码，第一个设置a的bit3，第二消除a的 bit 3。在以上两个操作中，要保持其它位不变.

```c++
#include <iostream>
#include <bitset>
using namespace std;

#define BIT3 (0x1<<3)
void set_bit3(unsigned &a)
{
	a |= BIT3;
}
void clear_bits(unsigned &a)
{
	a &= ~BIT3;
}

int main()
{
	unsigned a = UINT_MAX;
	clear_bits(a);
	cout << (bitset<32>)a << endl;
	set_bit3(a);
	cout << (bitset<32>)a << endl;
	return 0;
}
```

#### 行列递增矩阵的查找

解法一、分治法

因为矩阵的行和列都是递增的，所以整个矩阵的对角线上的数字也是递增的，故我们可以在对角线上进行二分查找，如果要找的数是6介于对角线上相邻的两个数4、10，可以排除掉左上和右下的两个矩形，而在左下和右上的两个矩形继续递归查找

解法二、定位法

首先直接定位到最右上角的元素，比要找的数大就往左走，比要找数的小就往下走，直到找到要找的数字为止，走不动，说明这个数不存在。这个方法的时间复杂度O（m+n）。代码如下：

```c++
#include <iostream>
#include <vector>
using namespace std;

bool YoungMatrix(vector< vector<int> > mat, int target){
	int y = 0, x = mat[y].size() - 1;
	int var = mat[y][x];
	while (true) {
		if (var == target){
			printf("Mat[%d][%d]=%d\n", y, x, target);
			return true;
		}
		else if (var < target && y < mat.size() - 1){
			var = mat[++y][x];
		}
		else if (var > target && x > 0){
			var = mat[y][--x];
		}
		else{
			return false;
		}
	}
}

int main(){
	vector<vector<int> > matrix(20);
	for (int i = 0; i < 20; i++){
		for (int j = 0; j < 20; j++) {
			matrix[i].push_back(i+j);
			cout << matrix[i][j] << " ";
		}
		cout << endl;
	}
	cout << YoungMatrix(matrix, 38) << endl;
	return 0;
}
```

#### 从1到500的500个数，第一次删除奇数位上的所有数，第二次删除剩下来的奇数位，以此类推，最后剩下的唯一一位数是什么？

就是当1~n，2^i<n<2^(i+1)时候，这样删除剩下的是2^i。2^8<500<2^9，所以剩下的就是2^8=256。

#### 给出了一个n*n的矩形，编程求从左上角到右下角的路径数（n > =2），限制只能向右或向下移动，不能回退。例如当n=2时，有6条路径。

从左上角到右下角总共要走2n步，其中横向要走n步，所以总共就是$C_{2n}^n$次。

#### 给出一棵二叉树的前序和中序遍历，输出后续遍历的结果。

已知一棵二叉树前序遍历和中序遍历分别为ABDEGCFH和DBGEACHF，则该二叉树的后序遍历为多少？

```c++
#include <iostream>
#include <string>
using namespace std;

string Subsequent(string pre, string mid) {
	if (pre.size() != mid.size() || pre.empty()) return "";
	char root = pre[0];
	int rootIndex = mid.find(root);
	string leftPre = pre.substr(1, rootIndex);
	string leftMid = mid.substr(0, rootIndex);
	string rightPre = pre.substr(rootIndex + 1);
	string rightMid = mid.substr(rootIndex + 1);
	
	string res;
	res += Subsequent(leftPre, leftMid);
	res += Subsequent(rightPre, rightMid);
	res += root;
	return res;
}

int main(){
	string pre = "ABDEGCFH";
	string mid = "DBGEACHF";
	cout << Subsequent(pre, mid) << endl;
	return 0;
}
```

#### 自定义实现字符串转为整数的算法，例如把“123456”转成整数123456.(输入中可能存在符号，和数字)

代码见[github](https://github.com/liqiang311/snippets/blob/master/string/%E8%BD%AC%E6%95%B4%E6%95%B0.cpp)

#### 字符串最长公共子序列

动态规划推导式

![](https://box.kancloud.cn/2016-06-07_575683a585d0b.jpg)

代码见[github](https://github.com/liqiang311/snippets/blob/master/string/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.cpp)

#### 字符串最长公共子串

与上文区别是不等时的处理方式，和最后是整个矩阵中寻找最大值。

代码见[github](https://github.com/liqiang311/snippets/blob/master/string/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.cpp)

#### 请实现一个函数：最长顺子。输入很多个整数(1<=数值<=13)，返回其中可能组成的最长的一个顺子(顺子中数的个数代表顺的长度)； 其中数字1也可以代表14；

直方图

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

vector<int> LongestShunZi(vector<int> input) {
	// 统计直方图
	vector<int> hist;
	hist.resize(15);
	for (int i = 0; i < input.size(); i++)
		if (input[i] > 0 && input[i] < 15)
			hist[input[i]] ++;
	hist[14] = hist[1];
	//最大牌数
	int maxCount = 0;
	for (int i = 1; i < 15; i++)
		if (hist[i] > maxCount)
			maxCount = hist[i];
	//求结果
	int resLen = 0;
	int resCount = 0;
	int resEnd = 0;
	for (int i = 1; i <= maxCount; i++)
	{
		int len = 0;
		int longestLen = 0;
		int longestEnd = 1;
		for (int j = 1; j < 15; j++) {
			if (hist[j] >= i) {
				len++;
				if (len > longestLen) {
					longestLen = len;
					longestEnd = j;
				}
			}
			else {
				len = 0;
			}
		}
		if (longestLen == 14 && 2 * i > hist[1]) longestLen--;
		if (longestLen * i > resLen * resCount) {
			resLen = longestLen;
			resCount = i;
			resEnd = longestEnd;
		}
	}

	vector<int> res;
	for (int i = resEnd - resLen + 1; i <= resEnd; i++)
		for (int j = 0; j < resCount; j++)
			res.push_back(i);
	return res;
}

int main() {
	int arr[] = { 1, 5, 2, 3, 4, 4, 5, 9, 6, 7, 2, 3, 3, 4 };
	vector<int> v(arr, arr+sizeof(arr)/sizeof(int));
	vector<int> res = LongestShunZi(v);
	for (int i = 0; i < res.size(); i++) cout << res[i] << " ";
	cout << endl;
	return 0;
}
```

#### 对一批编号为1-100，全部开关朝上(开)的亮灯进行如下操作

对一批编号为1-100，全部开关朝上(开)的亮灯进行如下操作：凡是编号为1的倍数的灯反方向拨一次开关；凡是编号为2的倍数的灯反方向又拨一次开关；编号为3的倍数的灯反方向又拨一次开关……凡是编号为100的倍数的灯反方向拨一次开关。编写程序，模拟此过程，最后打印出所熄灭灯的编号。

```c++
#include <iostream>
using namespace std;

int main() {
	bool arr[101];
	memset(arr, 0, 101);

	for (int i = 2; i <= 100; i++) {
		for (int j = 1; j <= 100; j++) {
			if (j % i == 0) {
				arr[j] = !arr[j];
			}
		}
	}
	for (int i = 1; i <= 100; i++) {
		if (!arr[i])
			cout << i << endl;
	}
	return 0;
}
```

```
1
4
9
16
25
36
49
64
81
100
```

一个数的约数个数为奇数。所有的数都包含1和自己，平方数的约数肯定是奇数个。

#### 实现个函数 `unsigned int convect(char* pstr)`

实现个函数 `unsigned int convect(char* pstr)`。其中`pstr`是十六进制数的字符串。函数`convect`将`pstr`转换成数字返回（比如：字符串'1A'，将返回数值26.注意，`pstr[0]`是'1'）。`pstr`中只有数字字符0到9、A到F。不得借助其它的系统函数调用。

```c++
#include <iostream>
using namespace std;

unsigned int convect(char* pstr) {
	char *p = pstr;
	unsigned long long res = 1;
	unsigned long long maxInt = (res << 32) - 1;
	res = 0;
	while (*p != '\0') {
		if (*p >= '0' && *p <= '9') {
			res = res * 16 + *p - '0';
		}
		else if (*p >= 'A' && *p <= 'F') {
			res = res * 16 + *p - 'A' + 10;
		}
		else return 0;
		p++;
	}
	if (res > maxInt) return 0;
	return res;
}

int main() {
	cout << convect((char*)"1A") << endl;
	cout << convect((char*)"FFFFFFFF") << endl;
	cout << convect((char*)"FFFFFFFFF") << endl;
	return 0;
}
```

#### 实现一个函数`unsigned int counter(char* pstr)`

实现一个函数`unsigned int counter(char* pstr)`。函数将打印出匹配的括号对。比如：字符串"a(bc(d)ef(12)g)"就存在3对匹配的括号对，分别是：
1. 位置4上的（与位置6上的）匹配。打印4 6即可。
1. 位置9上的（与位置12上的）匹配。打印9 12即可。
1. 位置1上的（与位置14上的）匹配。打印1 14即可。


## 软件编程部分

### 设计

#### 给你一个模块要求，你要做出这个模块，那么你的做出该模块的思路和步骤是什么？

明确这个模块的功能，明确其输入以及输出。

尽量去除与其他模块的耦合关系，确保独立性。

我会首先编写输入和输出的接口函数，然后由粗到精，逐步实现细节算法。

同时还需要编写模块的测试代码，保证交付的可靠性。

## Matlab编程

#### Matlab 中读、写及显示一幅图像的命令各是什么？

imread(), imwrite(), imshow()

#### Matlab 与VC++混合编程有哪几种方式？

Matlab引擎方式(Matlab后台程序为服务器，VC前端为客户端，C/S结构)、Matlab编译器（将Matlab源代码编译为C++可以调用的库文件）及COM组件（Matlab生成COM组件，VC调用）

#### Matlab运算中 `.*`和 `*` 的区别？

`.*`表示矩阵元素分别相乘，要求两个矩阵具有相同的shape。`*`表示矩阵相乘。

## 逻辑推理部分

### 智力题

#### 药丸问题

有四人装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被污染的重量+1．只称量一次，如何判断哪个罐子的药被污染了？

答：在四个罐子里面分别取1、2、3、4颗药丸，然后进行称量。如果称量结果比实际（污染前）重了n，就是第n罐被污染了。 (因为每加一颗被污染的药丸就增加1所以增加n就是增加n颗就是在第n个罐子里拿的）

#### 帽子黑白问题

一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其他人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？

解：假如只有一个人戴黑帽子，那他看到所有人都戴白帽，在第一次关灯时就应自打耳光，所以应该不止一个人戴黑帽子；如果有两顶黑帽子，第一次两人都只看到对方头上的黑帽子，不敢确定自己的颜色，但到第二次关灯，这两人应该明白，如果自己戴着白帽，那对方早在上一次就应打耳光了，因此自己戴的也是黑帽子，于是也会有耳光声响起；可事实是第三次才响起了耳光声，说明全场不止两顶黑帽，依此类推，应该是关了几次灯，有几顶黑帽。

#### 金条问题

让工人为你工作7天，给工人的回报是一根金条。金条平分成相连的7段，你必须在每天结束时给他们一段金条，如果只许你两次把金条弄断，你如何给你的工人付费？

答：分成1、2、4段。利用1，2，4可以组合成1,2,3,4,5,6,7

#### 拆字游戏

下面玩一个拆字游戏，所有字母的顺序都被打乱。你要判断这个字是什么。假设这个被拆开的字由5个字母组成：
1. 共有多少种可能的组合方式？
2. 如果我们知道是哪5个字母，那会怎么样？
3. 找出一种解决这个问题的方法。

个人解答：
1. $A_5^5=5*4*3*2*1=120$
1. 会依靠英文字母的规则等大致弄几种可能性出来。
1. 将弄出来的可能性的单词进行查找。

#### 为什么下水道的盖子是圆的？

解：很大程度上取决于下水道的形状，一般为了使得各个方向的管子都可以接入到下水道中，所以下水道设计成了圆柱形，所以盖子相应的也是圆形。且圆形比较省材料，便于运输。

#### 请估算一下CNTOWER电视塔的质量

首先在纸上画出了CNTOWER的草图，然后快速估算支架和各柱的高度，以及球的半径，算出各部分体积，然后和各部分密度运算，最后相加得出一个结果。






